# RC4 Stream Cipher Implementation

This repository contains a Python script that implements the RC4 stream cipher for educational purposes. RC4 is a widely known stream cipher, and this implementation demonstrates its core components: the Key-Scheduling Algorithm (KSA) and the Pseudo-Random Generation Algorithm (PRGA).

## About RC4

RC4 is a variable key-size stream cipher with byte-oriented operations. The algorithm is based on the use of a random permutation. Analysis has shown that the security of RC4 can be questionable if not used correctly (e.g., with non-random or related keys). This implementation is intended for learning about how stream ciphers work and should not be used in production environments for securing sensitive data.

## Features

-   **RC4 Encryption and Decryption:** A single function `rc4()` handles both encrypting and decrypting data.
-   **Key-Scheduling Algorithm (KSA):** Initializes and permutes a state vector based on the secret key.
-   **Pseudo-Random Generation Algorithm (PRGA):** Generates a keystream that is XORed with the data.
-   **Example Usage:** The script includes a clear example of how to encrypt a plaintext message and then decrypt the resulting ciphertext.

## How It Works

The `rc4` function performs the following steps:

1.  **Key-Scheduling Algorithm (KSA):**
    -   A state array `S` is initialized with values from 0 to 255.
    -   The state array is then permuted based on the bytes of the secret key.

2.  **Pseudo-Random Generation Algorithm (PRGA):**
    -   A keystream of the same length as the input text is generated by systematically swapping elements in the state array.

3.  **XOR Operation:**
    -   Each byte of the input text (plaintext or ciphertext) is XORed with a corresponding byte from the keystream to produce the output.

## A Closer Look at the XOR Operation

To understand how encryption and decryption work at a fundamental level, let's look at how the XOR operation transforms a single character.

The core principle is: `(A XOR B) XOR B = A`

This means that if you XOR a character with a key to encrypt it, you can get the original character back by XORing the result with the same key.

Let's take the first letter of our plaintext, 'T', and the first byte of the generated keystream.

**1. The Inputs (as numbers):**
*   **Plaintext character:** 'T' is represented by the ASCII value `84`.
*   **Keystream byte:** Let's imagine the first byte generated by the PRGA is `15`.

**2. Encryption:**
We XOR the ASCII value of the plaintext character with the keystream byte.

*   `84 XOR 15`
*   In binary: `01010100 XOR 00001111`
*   The result is `01011011`, which is `91` in decimal.
*   The ASCII character for `91` is `[`.

So, the character 'T' is encrypted into the character `[`. This is the "jumbling up" process.

**3. Decryption:**
Now, we take the encrypted character `[` and XOR it with the *same* keystream byte `15`.

*   `91 XOR 15`
*   In binary: `01011011 XOR 00001111`
*   The result is `01010100`, which is `84` in decimal.
*   The ASCII character for `84` is 'T'.

We have successfully decrypted the character back to the original 'T'. This process is repeated for every character in the message, each with its corresponding keystream byte.

## Prerequisites

-   Python 3.x

## How to Use

1.  Clone the repository:
    ```bash
    git clone https://github.com/your-username/secret-key-exercise.git
    cd secret-key-exercise
    ```

2.  Run the script:
    ```bash
    python secret_key_exercise.py
    ```

    The script will execute the example usage block, encrypt a sample message, and then decrypt it back to the original plaintext, printing the results to the console.

    ```
    Plaintext:  'This is a secret message.'
    Ciphertext (hex): 74686973206973206120736563726574206d6573736167652e
    Decrypted:  'This is a secret message.'
    ```

## Disclaimer

**This implementation is for educational purposes only.** RC4 is known to have vulnerabilities and is not considered secure for modern applications. Do not use this code for protecting sensitive information in a real-world scenario. Always use well-vetted, standard cryptographic libraries like `cryptography` in Python for any real security needs.

## Diagram Generation

This project includes a Python script (`generate_diagram.py`) that uses the `diagrams` library to visualize the RC4 process. 

### Requirements

- Python 3.x
- `diagrams` library (`pip install diagrams`)
- Graphviz (see installation instructions below)

### How to Generate the Diagrams

1.  **Install Graphviz:**
    -   **macOS (using Homebrew):**
        ```bash
        brew install graphviz
        ```
    -   **Debian/Ubuntu:**
        ```bash
        sudo apt-get install graphviz
        ```
    -   For other systems, refer to the [official Graphviz download page](https://graphviz.org/download/).

2.  **Run the script:**
    ```bash
    python generate_diagram.py
    ```

This will create two files in the project directory:

-   `rc4_flow_diagram.png`: Shows the high-level flow of the RC4 encryption process.
-   `xor_operation_detail.png`: Provides a closer look at the byte-by-byte XOR operation.

### Diagram Source Code

```python
# generate_diagram.py
from diagrams import Diagram, Cluster
from diagrams.programming.flowchart import Document, InputOutput, PredefinedProcess

# This script requires the 'diagrams' library and graphviz to be installed.
# You can install them with:
# pip install diagrams
#
# On macOS, you can install graphviz with Homebrew:
# brew install graphviz
#
# On Debian/Ubuntu, you can install graphviz with apt-get:
# sudo apt-get install graphviz
#
# For other systems, please see the Graphviz installation instructions.

# Diagram 1: Overall RC4 Flow
with Diagram("RC4 Stream Cipher Flow", show=False, filename="rc4_flow_diagram", direction="LR"):
    plaintext = Document("Plaintext")
    secret_key = InputOutput("Secret Key")

    with Cluster("RC4 Encryption Process (rc4 function)"):
        # The two main algorithms within RC4
        ksa_process = PredefinedProcess("1. Key-Scheduling\nAlgorithm (KSA)")
        prga_process = PredefinedProcess("2. Pseudo-Random\nGeneration (PRGA)")
        
        # The operation that combines the keystream and plaintext
        xor_operation = PredefinedProcess("3. XOR Operation")

        # Data flow within the cluster
        secret_key >> ksa_process >> prga_process
        prga_process >> xor_operation

    ciphertext = Document("Ciphertext")

    # Connect the external inputs/outputs to the process
    plaintext >> xor_operation
    xor_operation >> ciphertext

# Diagram 2: Detailed XOR Operation
with Diagram("XOR Operation Details", show=False, filename="xor_operation_detail", direction="TB"):
    plaintext_input = InputOutput("Plaintext / Ciphertext")
    keystream_input = InputOutput("Keystream from PRGA")
    
    xor_node = PredefinedProcess("Byte-by-byte\nXOR")

    ciphertext_output = Document("Ciphertext / Plaintext")

    plaintext_input >> xor_node
    keystream_input >> xor_node
    xor_node >> ciphertext_output


print("Diagram script 'generate_diagram.py' updated successfully.")
print("Run 'python generate_diagram.py' to create two diagram files:")
print("- rc4_flow_diagram.png (Overall flow)")
print("- xor_operation_detail.png (XOR step details)")

```
