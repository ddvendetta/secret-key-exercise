# RC4 Stream Cipher Implementation

This repository contains a Python script that implements the RC4 stream cipher for educational purposes. RC4 is a widely known stream cipher, and this implementation demonstrates its core components: the Key-Scheduling Algorithm (KSA) and the Pseudo-Random Generation Algorithm (PRGA).

## About RC4

RC4 is a variable key-size stream cipher with byte-oriented operations. The algorithm is based on the use of a random permutation. Analysis has shown that the security of RC4 can be questionable if not used correctly (e.g., with non-random or related keys). This implementation is intended for learning about how stream ciphers work and should not be used in production environments for securing sensitive data.

## Features

-   **RC4 Encryption and Decryption:** A single function `rc4()` handles both encrypting and decrypting data.
-   **Key-Scheduling Algorithm (KSA):** Initializes and permutes a state vector based on the secret key.
-   **Pseudo-Random Generation Algorithm (PRGA):** Generates a keystream that is XORed with the data.
-   **Example Usage:** The script includes a clear example of how to encrypt a plaintext message and then decrypt the resulting ciphertext.

## How It Works

The `rc4` function performs the following steps:

1.  **Key-Scheduling Algorithm (KSA):**
    -   A state array `S` is initialized with values from 0 to 255.
    -   The state array is then permuted based on the bytes of the secret key.

2.  **Pseudo-Random Generation Algorithm (PRGA):**
    -   A keystream of the same length as the input text is generated by systematically swapping elements in the state array.

3.  **XOR Operation:**
    -   Each byte of the input text (plaintext or ciphertext) is XORed with a corresponding byte from the keystream to produce the output.

## A Closer Look at the XOR Operation

To understand how encryption and decryption work at a fundamental level, let's look at how the XOR operation transforms a single character.

The core principle is: `(A XOR B) XOR B = A`

This means that if you XOR a character with a key to encrypt it, you can get the original character back by XORing the result with the same key.

Let's take the first letter of our plaintext, 'T', and the first byte of the generated keystream.

**1. The Inputs (as numbers):**
*   **Plaintext character:** 'T' is represented by the ASCII value `84`.
*   **Keystream byte:** Let's imagine the first byte generated by the PRGA is `15`.

**2. Encryption:**
We XOR the ASCII value of the plaintext character with the keystream byte.

*   `84 XOR 15`
*   In binary: `01010100 XOR 00001111`
*   The result is `01011011`, which is `91` in decimal.
*   The ASCII character for `91` is `[`.

So, the character 'T' is encrypted into the character `[`. This is the "jumbling up" process.

**3. Decryption:**
Now, we take the encrypted character `[` and XOR it with the *same* keystream byte `15`.

*   `91 XOR 15`
*   In binary: `01011011 XOR 00001111`
*   The result is `01010100`, which is `84` in decimal.
*   The ASCII character for `84` is 'T'.

We have successfully decrypted the character back to the original 'T'. This process is repeated for every character in the message, each with its corresponding keystream byte.

## Prerequisites

-   Python 3.x

## How to Use

1.  Clone the repository:
    ```bash
    git clone https://github.com/your-username/secret-key-exercise.git
    cd secret-key-exercise
    ```

2.  Run the script:
    ```bash
    python secret_key_exercise.py
    ```

    The script will execute the example usage block, encrypt a sample message, and then decrypt it back to the original plaintext, printing the results to the console.

    ```
    Plaintext:  'This is a secret message.'
    Ciphertext (hex): 74686973206973206120736563726574206d6573736167652e
    Decrypted:  'This is a secret message.'
    ```

## Disclaimer

**This implementation is for educational purposes only.** RC4 is known to have vulnerabilities and is not considered secure for modern applications. Do not use this code for protecting sensitive information in a real-world scenario. Always use well-vetted, standard cryptographic libraries like `cryptography` in Python for any real security needs.
